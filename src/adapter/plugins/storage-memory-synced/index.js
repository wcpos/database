import{replicateRxStorageInstance as e,randomCouchString as t,awaitRxStorageReplicationFirstInSync as s,STORAGE_TOKEN_DOCUMENT_ID as a,flatClone as n,rxStorageInstanceToReplicationHandler as r,ensureRxStorageInstanceParamsAreCorrect as i,INTERNAL_STORE_SCHEMA_TITLE as o,defaultHashSha256 as c,getRxReplicationMetaInstanceSchema as m}from"rxdb";import{RX_LOCAL_DOCUMENT_SCHEMA as h}from"rxdb/plugins/local-documents";import{getRxStorageMemory as d}from"rxdb/plugins/storage-memory";import{MemorySyncedRxStorageInstance as l}from"./memory-synced-storage-instance";import{filter as g,firstValueFrom as p,Subject as u}from"rxjs";import{checkVersion as f}from"../../shared/version-check";var y=d();export var RxStorageMemorySynced=function(){function d(e){this.name="memory-synced",this.statics=Object.assign({},y.statics,{prepareQuery:(e,t)=>e.title===o?this.settings.storage.statics.prepareQuery(e,t):y.statics.prepareQuery(e,t)}),this.firstInstanceTokens={},this.settings=e}return d.prototype.createStorageInstance=async function(d){i(d),f();var I=d.databaseInstanceToken,S=this;if(d.schema.attachments)throw new Error("The memory-synced plugin does not support attachments");if(d.schema.title===o){var b=await this.settings.storage.createStorageInstance(d),k=b.bulkWrite.bind(b);return b.bulkWrite=async function(e,t){var s=await k(e,t);s.success[a]&&(s.success[a].data.instanceToken===I&&(S.firstInstanceTokens[I]=new Set));return s},b}if(d.schema.title===h.title)return await this.settings.storage.createStorageInstance(d);var x=n(d);this.settings.keepIndexesOnParent||(x.schema=n(x.schema),x.schema.indexes=[]);var w,v=this.settings.storage.createStorageInstance(x),T=y.createStorageInstance(Object.assign({},Object.assign({},d,{multiInstance:!1,databaseInstanceToken:t(10)}),{collectionName:d.collectionName+"-memory-synced-"+t(12)})),N=y.createStorageInstance({databaseName:d.databaseName,collectionName:d.collectionName+"-meta-instance"+t(12),schema:m(d.schema,!1),multiInstance:!1,databaseInstanceToken:t(10),options:{},devMode:d.devMode}),P=new u,z=new u,M=Promise.all([T,N,v]).then((([s,a,n])=>{var i=async(e,s)=>{var a={id:t(10),context:s,input:e},n=p(z.pipe(g((e=>e.id===a.id))));return P.next(a),(await n).output},o=r(n,i,I);return e({identifier:"memorysyncedstorage+"+t(10),pullBatchSize:this.settings.batchSize?this.settings.batchSize:50,pushBatchSize:this.settings.batchSize?this.settings.batchSize:50,replicationHandler:o,conflictHandler:i,forkInstance:s,metaInstance:a,waitBeforePersist:this.settings.waitBeforePersist,hashFunction:c})}));return this.firstInstanceTokens[I]&&!this.firstInstanceTokens[I].has(d.collectionName)?(this.firstInstanceTokens[I].add(d.collectionName),w=T):w=M.then((e=>s(e))),new l(this,d.databaseName,d.collectionName,d.schema,{masterInstancePromise:v,metaInstancePromise:N,forkInstance:await T,initDonePromise:w,replicationStatePromise:M,conflictTasks$:P,resolvedConflictTasks$:z},{})},d}();export function getMemorySyncedRxStorage(e){return new RxStorageMemorySynced(e)}export*from"./memory-synced-types";export*from"./memory-synced-storage-instance";