import{flatClone as n,getPrimaryFieldOfPrimaryKey as e,getSortComparator as t}from"rxdb";import{merge as a,Subject as s}from"rxjs";import{getShardIndex as r,mergeSortedArray as i}from"./sharding-helper";export var RxStorageInstanceSharding=function(){function c(t,a,r,i,c,o){this.changes$=new s,this.storage=t,this.databaseName=a,this.collectionName=r,this.schema=i,this.internals=c,this.options=o,this.primaryPath=e(this.schema.primaryKey),this.internals.shardInstances.forEach(((e,t)=>{e.changeStream().subscribe((e=>{var a=n(e);a.checkpoint={[t]:e.checkpoint},this.changes$.next(a)}))}))}var o=c.prototype;return o.bulkWrite=async function(n,e){for(var t=this.internals.shardInstances,a=t.length,s=new Array(a).fill(0).map((()=>[])),i=0;i<n.length;++i){var c=n[i],o=c.document[this.primaryPath];s[r(a,o)].push(c)}var h={success:{},error:{}};return await Promise.all(s.map(((n,a)=>{if(n.length>0)return t[a].bulkWrite(n,e).then((n=>{for(var e=Object.keys(n.success),t=0;t<e.length;++t){var a=e[t];h.success[a]=n.success[a]}Object.keys(n.error).length>0&&Object.entries(n.error).forEach((([n,e])=>{h.error[n]=e}))}))}))),h},o.findDocumentsById=async function(n,e){for(var t=this.internals.shardInstances,a=t.length,s=new Array(a).fill(0).map((()=>[])),i=0;i<n.length;++i){var c=n[i];s[r(a,c)].push(c)}var o={};return await Promise.all(s.map(((n,a)=>{if(n.length>0)return t[a].findDocumentsById(n,e).then((n=>{for(var e=Object.keys(n),t=0;t<e.length;++t){var a=e[t];o[a]=n[a]}}))}))),o},o.query=async function(n){var e=n.originalQuery;e.limit&&e.limit;var a=e.skip?e.skip:0;var s=t(this.schema,n.originalQuery),r=[];return await Promise.all(this.internals.shardInstances.map((async e=>{var t=await e.query(n.parentPreparedQuery);r=i(r,t.documents,s)}))),r=r.slice(a),e.limit&&(r=r.slice(0,e.limit)),{documents:r}},o.count=async function(n){for(var e=await Promise.all(this.internals.shardInstances.map((async(e,t)=>(await e.count(n.parentPreparedQuery)).count))),t=0,a=e.length;a--;)t+=e[a];return{count:t,mode:"fast"}},o.getChangedDocumentsSince=async function(e,t){for(var a=this.internals.shardInstances,s=t?n(t):{},r=await Promise.all(a.map((async(n,t)=>{var a=s[t];return await n.getChangedDocumentsSince(e,a)}))),i=[],c=0,o=0;o<r.length&&c!==e;){var h=r[o],l=h.documents.length;if(c+l<=e)c+=l,i.push({checkpoint:h.checkpoint,documents:h.documents,shardIndex:o});else{var u=e-c,m=await a[o].getChangedDocumentsSince(u,s[o]);c+=m.documents.length,i.push({checkpoint:m.checkpoint,documents:m.documents,shardIndex:o})}o++}var d=[];return i.forEach((n=>{d=d.concat(n.documents),s[n.shardIndex]=n.checkpoint})),{documents:d,checkpoint:s}},o.getAttachmentData=function(n,e){var t=r(this.internals.shardInstances.length,n);return this.internals.shardInstances[t].getAttachmentData(n,e)},o.changeStream=function(){return this.changes$.asObservable()},o.cleanup=async function(n){return!(await Promise.all(this.internals.shardInstances.map((e=>e.cleanup(n))))).find((n=>!1===n))},o.close=function(){return this.changes$.complete(),Promise.all(this.internals.shardInstances.map((n=>n.close()))).then((()=>{}))},o.remove=function(){return this.changes$.complete(),Promise.all(this.internals.shardInstances.map((n=>n.remove()))).then((()=>{}))},o.conflictResultionTasks=function(){var n=this.internals.shardInstances.map((n=>n.conflictResultionTasks()));return a(...n)},o.resolveConflictResultionTask=function(n){return Promise.all(this.internals.shardInstances.map((e=>e.resolveConflictResultionTask(n)))).then((()=>{}))},c}();