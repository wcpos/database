import{flatClone as t,getPrimaryFieldOfPrimaryKey as n}from"rxdb";import{merge as e,Subject as s}from"rxjs";import{getShardIndex as a,mergeSortedArray as r}from"./sharding-helper";export var RxStorageInstanceSharding=function(){function i(e,a,r,i,c,o){this.changes$=new s,this.storage=e,this.databaseName=a,this.collectionName=r,this.schema=i,this.internals=c,this.options=o,this.primaryPath=n(this.schema.primaryKey),this.internals.shardInstances.forEach(((n,e)=>{n.changeStream().subscribe((n=>{var s=t(n);s.checkpoint={[e]:n.checkpoint},this.changes$.next(s)}))}))}var c=i.prototype;return c.bulkWrite=async function(t,n){for(var e=this.internals.shardInstances,s=e.length,r=new Array(s).fill(0).map((()=>[])),i=0;i<t.length;++i){var c=t[i],o=c.document[this.primaryPath];r[a(s,o)].push(c)}var h={success:{},error:{}};return await Promise.all(r.map(((t,s)=>{if(t.length>0)return e[s].bulkWrite(t,n).then((t=>{for(var n=Object.keys(t.success),e=0;e<n.length;++e){var s=n[e];h.success[s]=t.success[s]}Object.keys(t.error).length>0&&Object.entries(t.error).forEach((([t,n])=>{h.error[t]=n}))}))}))),h},c.findDocumentsById=async function(t,n){for(var e=this.internals.shardInstances,s=e.length,r=new Array(s).fill(0).map((()=>[])),i=0;i<t.length;++i){var c=t[i];r[a(s,c)].push(c)}var o={};return await Promise.all(r.map(((t,s)=>{if(t.length>0)return e[s].findDocumentsById(t,n).then((t=>{for(var n=Object.keys(t),e=0;e<n.length;++e){var s=n[e];o[s]=t[s]}}))}))),o},c.query=async function(t){var n=t.originalQuery;n.limit&&n.limit;var e=n.skip?n.skip:0;var s=this.storage.statics.getSortComparator(this.schema,t),a=[];return await Promise.all(this.internals.shardInstances.map((async n=>{var e=await n.query(t.parentPreparedQuery);a=r(a,e.documents,s)}))),a=a.slice(e),n.limit&&(a=a.slice(0,n.limit)),{documents:a}},c.count=async function(t){for(var n=await Promise.all(this.internals.shardInstances.map((async(n,e)=>(await n.count(t.parentPreparedQuery)).count))),e=0,s=n.length;s--;)e+=n[s];return{count:e,mode:"fast"}},c.getChangedDocumentsSince=async function(n,e){for(var s=this.internals.shardInstances,a=e?t(e):{},r=await Promise.all(s.map((async(t,e)=>{var s=a[e];return await t.getChangedDocumentsSince(n,s)}))),i=[],c=0,o=0;o<r.length&&c!==n;){var h=r[o],l=h.documents.length;if(c+l<=n)c+=l,i.push({checkpoint:h.checkpoint,documents:h.documents,shardIndex:o});else{var u=n-c,m=await s[o].getChangedDocumentsSince(u,a[o]);c+=m.documents.length,i.push({checkpoint:m.checkpoint,documents:m.documents,shardIndex:o})}o++}var p=[];return i.forEach((t=>{p=p.concat(t.documents),a[t.shardIndex]=t.checkpoint})),{documents:p,checkpoint:a}},c.getAttachmentData=function(t,n){var e=a(this.internals.shardInstances.length,t);return this.internals.shardInstances[e].getAttachmentData(t,n)},c.changeStream=function(){return this.changes$.asObservable()},c.cleanup=async function(t){return!(await Promise.all(this.internals.shardInstances.map((n=>n.cleanup(t))))).find((t=>!1===t))},c.close=function(){return this.changes$.complete(),Promise.all(this.internals.shardInstances.map((t=>t.close()))).then((()=>{}))},c.remove=function(){return this.changes$.complete(),Promise.all(this.internals.shardInstances.map((t=>t.remove()))).then((()=>{}))},c.conflictResultionTasks=function(){var t=this.internals.shardInstances.map((t=>t.conflictResultionTasks()));return e(...t)},c.resolveConflictResultionTask=function(t){return Promise.all(this.internals.shardInstances.map((n=>n.resolveConflictResultionTask(t)))).then((()=>{}))},i}();